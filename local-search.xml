<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>密码</title>
    <link href="/2023/02/07/%E5%AF%86%E7%A0%81/"/>
    <url>/2023/02/07/%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<ul><li><p>散列（hash）函数，对称加密，非对称加密</p></li><li><p>散列函数无密钥，能被彩虹表（一种以空间换时间的密码破解算法）破解，但可以通过添加盐的方式使之更不容易被破解，目的是获得文件的摘要（hash 值），可用于密码验证。如 MD5，SHA-2 等。</p></li><li><p>对称加密是指加密和解密的密钥相同。</p></li><li><p>非对称加密指加密和解密的密钥不同。一般来说公钥加密，私钥解密（公钥是公开的，如果所有人都可以用公钥解密那加密就没有意义了）。在数字签名时用私钥加密，公钥解密。即公钥和私钥都可以用来加密或解密。按照RSA算法的定义，公钥是(n,e) 私钥是(n,d)。从数学角度来说地位对等的。</p><p>  这只是从加密算法的角度讲，但实际上，私钥文件可以计算出公钥文件。这是因为私钥文件会包含更多信息（你会发现私钥文件更长），根据 pkcs （全称Public-Key Cryptography Standards （公开秘钥加密标准 ）），私钥包含(n,e,d,p,q)，公钥包含(n,e)。</p></li><li><p>对称加密常见有 AES，DES，IDEA；非对称加密常见有 RSA 算法</p></li><li><p>压缩包密码用到的就是对称加密，密钥即是输入的密码，但密码常常位数不够，需要 PBE（Password Based Encryption）算出真正的密钥。下载完整性验证用的散列函数。</p></li><li><p>为了解决传递密钥问题，提出了 DH 算法，确切来说 DH 算法是密钥协商算法，利用数学理论相互之间传递一些公开的值，自己保留一些值，最后计算出来的结果是一样的（神奇）。</p></li><li><p>非对称加密的有效攻击方式是中间人攻击。</p></li><li><p>签名算法是指私钥加密，公钥解密来确认是否是某个发送方发出的，使之不能被伪造。现实应用中不是对原始消息签名，而是对原始消息的 hash 值进行签名。而解密时将解密内容与 hash 值进行对比。</p><p>  数字签名用于：</p><ol><li>防止伪造；</li><li>防止抵赖；</li><li>防止篡改。</li></ol><p>  常用的数字签名算法包括：MD5withRSA／SHA1withRSA／SHA256withRSA／SHA1withDSA／SHA256withDSA／SHA512withDSA／ECDSA等。</p></li><li><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227968188450">数字证书</a></p></li><li><p><a href="https://blog.csdn.net/zyz770834013/article/details/81380608">ssh 具体流程</a>，服务器可能会被多个客户端连接，所以应该存公钥（否则私钥泄露），具体流程见链接。SSH 用账号密码登录也会有临时的不对称加密，所用到的公钥私钥不同于事先生成的。</p></li><li><p><a href="https://www.cnblogs.com/xjnotxj/p/9311160.html">ssh 学习</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>program</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cryptography</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo</title>
    <link href="/2023/02/07/hexo/"/>
    <url>/2023/02/07/hexo/</url>
    
    <content type="html"><![CDATA[<ul><li>public 文件夹是网站的实质内容</li><li>scaffolds 存模板</li><li>source 里面可以存源资源文件（如 文档，css，js，图片等）</li><li>hexo g 就会将 source 里面的资源文件转化为网站静态文件到 public 中。如更新各页面的 index.html，将 post.md 转化为相应时间目录的 html 文件，复制 source&#x2F;images 等文件夹到 public 中（如 images）等等。</li><li>hexo new page test 将产生一个新页面，在 source 文件中生成 test&#x2F;index.md，<code>hexo g</code>后将会在 <code>public</code> 中产生相应文件夹及 html 文件。</li><li>但神奇的是，没有 <code>hexo clean</code> 清除 public 文件夹后仍可以访问 source 中的资源…(从此来看，是 hexo 没有 public 时，会实时渲染 source 中的资源？)</li><li>部署服务器可以用 githubaction 来 ftp 传输。也可以用 ssh 。</li><li>目前采用方案是本机存储所有，服务器只部署 public 文件夹。将笔记目录与 source 目录创建软链接，忽略本来目录的 .md 文件，需要发布时，将文件移入 _posts 文件中。部署设置设为 git，github 仓库也只存 public 文件夹，再用 githubaction 将 public 文件夹传到服务器上，可能需要考虑运行清空脚本。</li></ul>]]></content>
    
    
    <categories>
      
      <category>program</category>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/02/01/markdown/"/>
    <url>/2023/02/01/markdown/</url>
    
    <content type="html"><![CDATA[<h2 id="some-tips"><a href="#some-tips" class="headerlink" title="some tips"></a>some tips</h2><ol><li>use # for head.</li><li>use two spaces and a return or &lt;br&gt; for a line break.</li><li>use a blank line for another paragraph.</li><li>use ** ** for bold.</li><li>use * * for italic.</li><li>use *** for bold and italic.</li><li>use &gt; for blockquotes.</li><li>use 1. for ordered list.</li><li>use - for unordered list.</li><li>use four spaces or a tab for adding elementsin list(remember to add a blank line to indicate it’s a new paragraph, or it maybe just a space. Associate it with the knowledge of block in html).</li><li>use `&#96;&#96; &#96;&#96;&#96; for block code.</li><li>use ` &#96; for inline code.</li><li>use double backticks enclosing the word for escaping `. like <code>he`llo</code></li><li>look link like this <a href="https://www.google.com/" title="google">google</a>.</li><li>quickly turn a URL or email address into a link. <a href="mailto:&#108;&#x6c;&#x6c;&#x65;&#105;&#103;&#x6f;&#105;&#110;&#x67;&#64;&#x67;&#x61;&#x6d;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;">&#108;&#x6c;&#x6c;&#x65;&#105;&#103;&#x6f;&#105;&#110;&#x67;&#64;&#x67;&#x61;&#x6d;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;</a> <a href="https://www.google.com/">https://www.google.com</a></li><li><a href="https://www.markdownguide.org/basic-syntax/#formatting-links">Formatting Links</a></li><li><a href="https://www.markdownguide.org/basic-syntax/#reference-style-links">Reference-style Links</a></li><li><a href="https://www.markdownguide.org/basic-syntax/#linking-images">Linking Images</a></li><li>see extended syntax <a href="https://www.markdownguide.org/extended-syntax/">https://www.markdownguide.org/extended-syntax/</a></li><li>GFM doesn’t support</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/2022/09/19/git/"/>
    <url>/2022/09/19/git/</url>
    
    <content type="html"><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="1-basics"><a href="#1-basics" class="headerlink" title="1. basics"></a>1. basics</h3><ul><li>ssh -T <a href="mailto:&#103;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#x6d;">&#103;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#x6d;</a> &#x2F;&#x2F;-T 就是不分配伪终端，只显示连接信息<br>   测试能否连接到 github<br>   确定已经有添加 ssh 密钥，确定 config 文件配置正确，确定能 ping 通 github.com</li><li>git init</li><li>git add (.)</li><li>git commit -m ‘’</li><li>git status</li><li>git rm</li><li>git cherry-pick &lt;commit&gt; (复制一个特定的提交到当前分支)</li><li>git blame filename 显示谁修改了文件</li></ul><h3 id="2-diff"><a href="#2-diff" class="headerlink" title="2. diff"></a>2. diff</h3><ul><li>git diff 工作区与暂存区<br>– &lt;filename&gt; 指定文件(注意空格)</li><li>git diff HEAD 工作区与 commit</li><li>git diff –chached(暂存区与commit)</li></ul><p>即未使用参数，默认是工作区与 xx 比较</p><h3 id="3-reset"><a href="#3-reset" class="headerlink" title="3. reset"></a>3. reset</h3><ul><li>git reset &lt;file&gt; (将某文件从暂存区移除，不修改工作区,不加文件是所有)</li><li>git reset –hard (移除暂存区修改，删除工作区修改)</li><li>git reset &lt;commit&gt; (可以用 head^ 回滚到指定版本，清除暂存区，但保持工作区不变)</li><li>git reset –hard &lt;commit&gt; (回滚到指定版本，清除暂存区，删除工作区修改)<br>git reflog 可以查看被删除的版本号</li></ul><p>–mixed 是默认参数，保留工作区，修改暂存区，不会移动 head 指针<br>–hard 修改工作区和暂存区，会移动 head 指针，此时提交会丢失指定版本之后的内容</p><h3 id="4-branch"><a href="#4-branch" class="headerlink" title="4. branch"></a>4. branch</h3><ul><li>git branch 显示分支</li><li>git branch &lt;branchname&gt; 创建分支<br>   -d 删除</li><li>git checkout &lt;branchname&gt; 切换分支<br>   -b &lt;name1&gt; (&lt;name2&gt;) 新建并切换到name1</li><li>git merge &lt;branchname&gt; 采用 Fast Forward 合并分支(此模式不会显示合并信息)<br>   –no-ff 不使用 Fast Forward 模式，会显示合并信息，会产生新的 commit 所以同时需要 -m 参数</li><li>git switch 作用同 checkout</li><li>git cherry pick &lt;commit&gt; 复制一个特定的提交到当前的分支(指复制相同的改动操作)</li><li>git rebase &lt;branchname&gt;</li><li>git branch –set-upstream-to &lt;branch-name&gt; origin&#x2F;&lt;branch-name&gt; 关联上游分支，不用记，会有提示</li></ul><h3 id="5-remote"><a href="#5-remote" class="headerlink" title="5. remote"></a>5. remote</h3><ul><li>git remote -v 查看远端仓库信息</li><li>git remote add &lt;name&gt; &lt;url&gt;(eg:<a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;</a>:llleixx&#x2F;helloworld.git)</li><li>git remote rm &lt;name&gt; 删除远程仓库的绑定</li><li>git pull</li><li>git push &lt;remotename&gt; &lt;branchname&gt;(:&lt;branchname&gt;) 将某个分支推送到远端某个分支<br>   -u 关联远程分支<br>   -f 强制</li><li>git fetch</li><li>git push origin –delete branchname  删除远端分支</li><li>git clone &lt;name&gt; (eg:<a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#x2e;&#x63;&#111;&#109;">&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#x2e;&#x63;&#111;&#109;</a>:llleixx&#x2F;helloworld.git)</li></ul><h3 id="6-log"><a href="#6-log" class="headerlink" title="6. log"></a>6. log</h3><ul><li>git log -&lt;limit&gt;<br>   &lt;limit&gt; 为最大显示数量</li><li>git log – &lt;file&gt;</li><li>git log –graph</li><li>git relog (命令历史)</li></ul><h3 id="7-stash"><a href="#7-stash" class="headerlink" title="7. stash"></a>7. stash</h3><ul><li>git stash 储存工作区和暂存区(切换分支会丢失工作区和暂存区信息)<br>   sava “message” 同时储存注释信息</li><li>git stash list 查看</li><li>git stash apply (&lt;stashname&gt;) 恢复但不删除stash，默认最新</li><li>git stash drop (&lt;stashname&gt;) 删除stash</li><li>git stash pop (&lt;stashname&gt;) 恢复并删除</li></ul><h3 id="8-tag"><a href="#8-tag" class="headerlink" title="8. tag"></a>8. tag</h3><ul><li>git tag 查看所有标签</li><li>git tag &lt;tagname&gt; 给 HEAD 指向打 tag<br>   -d 删除标签</li><li>git tag &lt;tagname&gt; &lt;commit&gt;</li><li>git tag -a &lt;tagname&gt; -m &lt;annotation&gt; &lt;commit&gt; 创有说明的标签</li><li>git show &lt;tagname&gt; 显示说明</li><li>git push origin &lt;tagname&gt; 推送某个标签<br>   –tags 是推送所有标签</li></ul><h3 id="9-config"><a href="#9-config" class="headerlink" title="9. config"></a>9. config</h3><ul><li>git config –global –list</li><li>git config –global user.name xx</li><li>git config –global user.email “<a href="mailto:&#x65;&#109;&#x61;&#x69;&#x6c;&#64;&#101;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#x65;&#109;&#x61;&#x69;&#x6c;&#64;&#101;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a> ”</li></ul><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><ol><li><p>HEAD表示当前分支最新提交版本，HEAD^上个版本，HEAD^^上上个版本，上100个版本可以写HEAD~100</p></li><li><p>git status 查看状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">Untracked files 未跟踪(新创建，从未add过的文件)<br>Changes not staged for commit 未add<br>Changes to be committed add但未commit<br></code></pre></td></tr></table></figure></li><li><p>分支间相同文件进行不同修改会有冲突，此时merge失败<br>此时可以用 git status 告诉我们冲突文件<br>查看文件内容，Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容<br>修改(修改成你想要的样子，可以与所有分支都不同)，add，commit。就能成功合并了(不用再merge，相当于merge失败→修改→add，commit→合并成功)</p></li><li><p>origin&#x2F;dev 像调用本地分支一样调用远程分支(其实两者没什么差别)</p></li><li><p>使用 https 协议，可以通过设置 credential helper 来只用第一次输入密码<br>git config –global credential.helper store  &#x2F;&#x2F;这是全局配置，执行后，会在用户目录下(这里没有指定位置)生成 .git_credential 里面存储着账号和密码</p></li><li><p>使用 ssh(git) 协议更快，设置密钥后才能使用</p></li><li><p>git merge 和 git rebase</p><p>git merge master feature 将 master 合并到 feature 上</p><p>git merge 每次合并上游更改时 feature 分支都会引入一个外来的合并提交。如果 master 非常活跃的话，这或多或少会污染你的分支历史。</p><p>git rebase 它会把整个 feature 分支移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来。但是，rebase 为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。</p><p>不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase 不会有合并提交中附带的信息——你看不到 feature 分支中并入了上游的哪些更改。</p><p>综上，rebase 适用于开发 feature 分支时，master 分支已经被更新，需要再在新的 master 分支下开发，这时就可以用 rebase 将当前分支移动到 新的master 分支后</p></li></ol><h2 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h2><ol><li><p>工作区：<br>git checkout – a.txt<br>git checkout – .  所有<br>git checkout &lt;commitID&gt;(head) &lt;filename&gt;</p></li><li><p>暂存区：<br>git reset HEAD .<br>git reset HEAD a.txt<br>不加参数是采用了默认的 –mixed 参数  </p><p>只改变暂存区，所以如果想再还原工作区，需要用到1</p></li><li><p>本地分支<br>git log 得到提交id<br>git reset –hard HEAD^ 回到最新的一次提交<br>git reset –hard <commit_id> 回到你想要的版本<br>git reset HEAD^ 此时代码保留，回到 git add 之前</p></li><li><p>远程仓库<br>git log<br>git reset –hard <commit_id><br>git push -f origin HEAD(或者当前分支名) 强制提交<br>or<br>git revert HEAD<br>git push origin master(不用 -f 了)</p></li><li><p>git rever 和 git reset 区别</p><p>- git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；<br>- git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除</p></li><li><p>git commit –amend -m ‘sdfa’</p><p>相当于删除上次提交，换成当前这次</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>program</category>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
